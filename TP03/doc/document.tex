\documentclass{article}

\usepackage{graphics}
\usepackage{graphicx}
\usepackage[a4paper,
            top=2cm,
            bottom=3cm,
            left=3cm,
            right=2cm,
            marginparwidth=1.75cm
            ]{geometry}

\usepackage{float}
\usepackage{subcaption}
\usepackage{hyperref}

\title{TP02 - Estrutura de dados}
\author{Marcos Daniel Souza Netto - 2022069492} 
\date{\today}

\begin{document}
\maketitle

\section{Introdução}

O problema proposto consiste em implementar um programa que realiza $q$ operações de dois tipos sobre um vetor de Matrizes 2x2: O primeiro tipo consiste em uma atualização de uma posição do vetor, e o segundo tipo consiste em uma consulta sobre um intervalo do vetor (Deve ser retornado a multiplicações de todas as matrizes do intervalo) e depois aplicar essa transformação linear a um vetor dado pelo usuário.

Note que uma solução ingênua para o problema seria: Dado a operação de atualização $i$ e a matriz $M$, basta atualizar a posição $i$ do vetor com a matriz $M$ (Custo constante). E para cada operação de consulta, basta percorrer o intervalo do vetor, multiplicando as matrizes e retornando o resultado e então multiplicá-lo pelo vetor. 
Porém, essa solução não é eficiente, pois uma operação de consulta desse tipo possui complexidade $O(n)$, e tendo em vista que vão ser realizadas um número grande de consultas, a complexidade passaria para $O(n \cdot q)$, onde $q$ é o número de consultas.

A solução implementada e também proposta pelos professores consiste em utilizar a ideia de \emph{Segment Tree}, que é uma estrutura de dados que permite realizar consultas em intervalos do vetor de forma eficiente. 

\section{Método}

A seguir serão detalhados a implementação da solução, de modo a explicitar 
as estruturas de dados utilizadas e as estratégias de solução. A priori vale 
apresentar as especificações do ambiente de desenvolvimento utilizado:

\begin{itemize}
    \item Sistema Operacional: Ubuntu 22.04.3 LTS;
    \item Compilador: G++ 11.4.0;
    \item Processador: Ryzen 5 5500u;
    \item Memória RAM: 8GB.
\end{itemize}


\subsection{Estruturas de dados}

Neste trabalho, foi utilizado apenas a estrutura de dados de \emph{Segment Tree}, que foi implementada no arquivo \emph{segtree.hpp}.

Como já mencionado anteriormente, essa estrutura de dados otimiza a consulta de intervalos de um vetor, e portanto, foi utilizada para otimizar a consulta de intervalos do vetor de matrizes.

A ideia é que cada nó da árvore representa um intervalo do vetor, e cada nó guarda o resultado da operação associada ao intervalo que ele representa e podemos combinar esses pedaços pré-computados para formar o resultado de uma consulta específica. Neste problema, cada nó guarda o resultado da multiplicação das matrizes do intervalo que ele representa. Assim, para realizar uma consulta, basta percorrer a árvore, e para cada nó, 
verificar se o intervalo que ele representa está contido no intervalo da consulta, caso esteja, basta retornar o valor guardado no nó, caso contrário, é necessário percorrer os filhos do nó, e repetir o processo.
Com esses pedaços, podemos combiná-los (aqui, multiplicá-los) para encontrar o resultado. Note que nessa estrutura de dados é importante que a operação a ser realizada deve ter a propriedade de associatividade (A ordem em que as operações são realizadas não altera o resultado), e no caso da multiplicação de matrizes, essa propriedade é satisfeita.

Para não entrar nos detalhes dessa estrutura de dados, a implementação utilizada foi baseada na aula 9 da Maratona UFMG, disponível em: \url{https://youtu.be/OW_nQN-UQhA?si=4qCz2jhB6BHWVRMz}. 

\subsubsection*{Propriedades da \emph{Segment Tree}} \label{sec:prop_segtree}
\begin{itemize}
    \item A altura da árvore é $O(\log n)$, onde $n$ é o número de elementos do vetor;
    \item O número total de nós da árvore é $2n -1$, onde $n$ é o número de elementos do vetor;
    \item Para a consulta de um intervalo na árvore, visitamos no máximo 4 nós por nível, temos então $O(4 \cdot \log n) = O(\log n)$, onde $n$ é o número de elementos do vetor;
\end{itemize}



\subsubsection*{Complexidade}
\begin{itemize}
    \item Para a construção da estrutura temos complexidade $O(n)$;
    \item Para a consulta na estrutura temos complexidade $O(\log n)$;
    \item Para a atualização de uma posição do vetor temos complexidade $O(\log n)$;
\end{itemize}


\subsection{Classes e principais funções}
O código foi dividido nos arquivos \emph{matrix2.hpp}, \emph{segtree.hpp} e o arquivo principal \emph{main.cpp}.
\begin{itemize}
    \item \textbf{matrix2.hpp}: Encapsulamento do tipo abstrato de dados de matriz 2x2, com as operações de multiplicação e atribuição;
        \subitem \textbf{Matrix2()}: O construtor padrão desse TAD inicializa a matriz com a matriz identidade;
        \subitem \textbf{Matrix2(int, int, int, int)}: O construtor desse TAD recebe os valores dos elementos da matriz;
        \subitem \textbf{operator*}: Sobrecarga do operador de multiplicação, que recebe uma matriz e retorna a multiplicação das duas matrizes; 

    \item \textbf{segtree.hpp}: Implementação da estrutura de dados árvore de segmentos;
        \subitem \textbf{query}: Função que recebe o intervalo da consulta e retorna a multiplicação das matrizes do intervalo;
        \subitem \textbf{update}: Função que recebe a posição do vetor a ser atualizada e a nova matriz, e atualiza a posição do vetor com a nova matriz, recalculando os valores dos nós da árvore que foram afetados pela atualização;

    \item \textbf{main.cpp}: Arquivo principal do programa que recebe os dados de entrada, os valida, e faz chamada para as funções de atualização e consulta da árvore de segmentos;
        \subitem \textbf{main}: Função principal do programa, que recebe os dados de entrada, os valida, faz chamada para as funções de atualização e consulta da árvore de segmentos e mostra o resultado das consultas na saída padrão;
    
\end{itemize}

\section{Análise de Complexidade}

A seguir serão apresentadas as análises de complexidade das principais funções do programa utilizadas na solução.
Como a parte mais importante é a implementação da árvore de segmentos, a análise de complexidade será feita para as funções de construção, consulta e atualização da árvore de segmentos.

\subsection{Construtor}
A forma implementada para a construção da árvore de segmentos foi a inicialização de todas as posições do vetor que a representa com a matriz identidade. 
Dessa forma, como o tamanho do vetor é $4n + 1$, onde $n$ é o número de transformações lineares informada na entrada, temos que a complexidade da construção da árvore é $O(n)$.

\subsection{Função \emph{query}}

Como mencionada na seção \ref{sec:prop_segtree}, a complexidade da consulta na árvore de segmentos é $O(\log n)$, onde $n$ é o número de elementos do vetor. Isso acontece porque são necessário acessar no máximo 4 nós por nível da árvore para a construção da consulta, e a altura da árvore é $O(\log n)$.

\subsection{Função \emph{update}}

De forma semelhante à função \emph{query}, para atualizar a árvore com os intervalos já pré-computados, temos que atualizar uma folha da árvore de segmentos e em seguida subir na estrutura recalculando os valores dos nós pais. 
Poranto, temos a complexidade de atualização como $O(\log n)$.

\subsection{Complexidade geral}

Analisando o programa como um todo, temos que :
\begin{enumerate}
    \item A complexidade da construção da árvore de segmentos é $O(n)$ que é realizada uma única vez;
    \item A complexidade de uma operação, tanto de consulta quanto de atualização, é $O(\log n)$, e é realizada $q$ vezes;
\end{enumerate}


Portanto, a complexidade de tempo do programa é $O(n + q \cdot \log n)$, onde $n$ é o número de transformações lineares informada na entrada e $q$ é o número de consultas informada na entrada.
Já a complexidade de espaço é $O(n)$, pois é necessário armazenar a árvore de segmentos, que neste caso tem o tamanho de $4n + 1$.

\section{Estratégias de robustez}
Com a utilização da biblioteca \emph{msgassert}, presente no arquivo \emph{msgassert.h}, foi implementada a verificação do domínio dos dados de entrada, especificados na descrição do trabalho. 
Quando o dado de entrada não respeita o domínio especificado, o programa é encerrado e uma mensagem do erro específico é exibida na saída padrão de erro.

\section{Análise Experimental}

A seguir serão apresentados os resultados obtidos na experimentação do programa.

\subsection{Localidade de Referência}

Utilizando o programa \emph{analisamem}, fornecido pelos professores, foi possível observar a localidade de referência do programa. 
Para isso, foi utilizado o programa de geração de casos de testes, também fornecido pelos professores, para gerar um grafo com 100 vértices e 200 arestas com coloração gulosa.

\subsubsection{Grafo }
Nesta fase, assim como a seguinte, são idênticas para os sete testes que foram realizados, e portanto, serão apresentadas apenas uma vez. Isso se deve porque cada teste foi realizado com um método de ordenação diferente, e portanto, a única diferença entre eles é a função de ordenação utilizada.


    % % \begin{figure}[H]
    % %     \centering
    % %     \hfill
    % %     \begin{subfigure}[c]{0.4\textwidth}
    % %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/common/registro_a-acesso-0.png}
    %         \caption{Acesso de memória do grafo}
    %         \label{fig:ac01}
    %     \end{subfigure}%
    %     \hfill
    %     \begin{subfigure}[c]{0.4\linewidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/common/registro_a-distp-0.png}
    %         \caption{Distância da pilha na leitura dos dados}
    %         \label{fig:ac02}
    %     \end{subfigure}
    %     \hfill
    %     \caption{Leitura dos dados}
    % \end{figure}

    % Nada de muito interessante aqui, tanto que me ambas as figuras podemos observar que na metade a esquerda do gráfico a leitura dos vértices e seus adjacentes e na segunda metade a leitura do grafo para verificar a gulosidade.
            
    % \subsubsection{Verificação de Gulosidade}

    % \begin{figure}[H]
    %     \centering
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/common/registro_a-hist-1-0.png}
    %         \caption{Lista de adjacência do grafo}
    %         \label{fig:ac03}
    %     \end{subfigure}
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/common/registro_a-hist-1-1.png}
    %         \caption{Vetor de cores}
    %         \label{fig:ac04}
    %     \end{subfigure}
    %     \hfill
    %     \caption{Frequência de distância de pilha na verificação de gulosidade}

    % \end{figure}

    % Observe que o algoritmo de verificação de gulosidade é bem simples, e ainda possue uma boa localidade 
    % de referência, uma vez que em geral estamos trabalho com espaços de memória contíguos, e esses acessos 
    % são feitos de forma sequencial. Distâncias de pilha maiores significam que estamos no geral mudando o vetor 
    % de adjacência que estamos percorrendo.
    % \subsubsection{Ordenação}

    % Aqui, vamos detalhar principalmente sobre a localidade de referência do método de ordenação próprio, afinal
    % os demais métodos foram implementados nas suas versões clássicas. Fica como sugestão a análise dos demais métodos. 
    % \begin{figure}[H]
    %     \centering
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/bubblesort/registro_a-distp-1.png}
    %         \caption{Método por bolha}
    %         \label{fig:ac05}
    %     \end{subfigure}
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/selectionsort/registro_a-distp-1.png}
    %         \caption{Método por Seleção}
    %         \label{fig:ac06}
    %     \end{subfigure}
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/inserctionsort/registro_a-distp-1.png}
    %         \caption{Método por Inserção}
    %         \label{fig:ac07}
    %     \end{subfigure}
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/heapsort/registro_a-distp-1.png}
    %         \caption{Método do Heap}
    %         \label{fig:ac08}
    %     \end{subfigure}
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/quickSort/registro_a-distp-1.png}
    %         \caption{Método do QuickSort}   
    %         \label{fig:ac09}
    %     \end{subfigure}
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/mergesort/registro_a-distp-1.png}
    %         \caption{Método do MergeSort}
    %         \label{fig:ac10}
    %     \end{subfigure}
    %     \hfill
    %     \begin{subfigure}[c]{0.4\textwidth}
    %         \centering
    %         \includegraphics[width=\textwidth]{./images/100-200/my_sort/registro_a-distp-1.png}
    %         \caption{Método próprio}
    %         \label{fig:a11}
    %     \end{subfigure}
    %     \hfill
    %     \caption{Frequência de distância de pilha nos métodos de ordenação}

    % \end{figure}

Observe que a figura \ref{fig:a11} (Ordenação própria) se assemelha bastante à figura \ref{fig:ac10} (MergeSort), isso se deve porque a ordenação própria possui a primeira etapa de separar os vértices, como já descrito anteriormente, e o mergesort com o processo de partições. 
E na segunda etapa, ambos possuem a mesma ideia de percorrer os subvetores ordenados e atribuir os elementos para o vetor original, que no caso do \emph{mergesort} é repetido diversas vezes. Pode-se se certificar desse comportamento devido às "barras" de mesma distância de pilha presentes no final do gráfico. 


\section{Conclusões}

O trabalho proposto foi de grande valia para o aprendizado de estruturas de dados, e de como elas podem ser utilizadas para solucionar problemas, afinal foi de importância considerável a utilização de árvores (\emph{set}) e a representação como lista de adjacência de um grafo como estruturas principais, para se ter uma complexidade menor no algoritmo como todo. Ademais, temos também o uso dos métodos de ordenação, mas que nesse trabalho ficaram em segundo plano.


\section*{Bibliografia}

Slides da disciplina de Estrutura de Dados, ministrada pelo Prof. Wagner Meira Jr. e Prof. Eder Fereira Figuiredo.


Aula 9 - SegTree, Maratona UFMG. 

Disponível em: \url{https://youtu.be/OW_nQN-UQhA?si=4qCz2jhB6BHWVRMz}

\section*{Instruções para compilação e execução}

É necessário ter instalado na máquina o compilador g++, com pelo mínimo a versão descrita no começo do trabalho.  

Em um terminal, navegue até a pasta raiz do projeto e execute os seguintes comandos:

\begin{verbatim}
    $ make
    $ ./tp03.out

\end{verbatim}

Agora, basta seguir o padrão de entrada descrito na especificação do trabalho.


\end{document}