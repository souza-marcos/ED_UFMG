--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         8388608 B, 64 B, direct-mapped
Command:          ./bin/tp01 -s 0 | 1 & 2 & 3 e11e
Data file:        cachegrind.out.116922
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                 I1mr           ILmr           Dr               D1mr            DLmr           Dw               D1mw           DLmw           
--------------------------------------------------------------------------------
2,391,326 (100.0%) 2,276 (100.0%) 2,167 (100.0%) 577,469 (100.0%) 13,987 (100.0%) 7,815 (100.0%) 209,080 (100.0%) 2,487 (100.0%) 1,622 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir               I1mr         ILmr         Dr               D1mr           DLmr           Dw              D1mw           DLmw          file:function
--------------------------------------------------------------------------------
998,362 (41.75%)  11 ( 0.48%)  11 ( 0.51%) 167,122 (28.94%) 2,012 (14.38%) 1,676 (21.45%) 53,545 (25.61%)    15 ( 0.60%)   1 ( 0.06%)  ./elf/./elf/dl-lookup.c:_dl_lookup_symbol_x
578,326 (24.18%)  35 ( 1.54%)  35 ( 1.62%) 193,282 (33.47%) 3,993 (28.55%)   837 (10.71%) 81,235 (38.85%)    65 ( 2.61%)  38 ( 2.34%)  ./elf/./elf/dl-lookup.c:do_lookup_x
262,956 (11.00%)  27 ( 1.19%)  27 ( 1.25%)  65,679 (11.37%) 2,918 (20.86%) 2,448 (31.32%) 21,963 (10.50%) 1,660 (66.75%) 914 (56.35%)  ./elf/../sysdeps/x86_64/dl-machine.h:_dl_relocate_object
120,638 ( 5.04%)   6 ( 0.26%)   6 ( 0.28%)  40,204 ( 6.96%)   480 ( 3.43%)   250 ( 3.20%) 13,448 ( 6.43%)     8 ( 0.32%)   1 ( 0.06%)  ./elf/./elf/dl-lookup.c:check_match
109,503 ( 4.58%)  17 ( 0.75%)  17 ( 0.78%)  34,524 ( 5.98%) 2,767 (19.78%) 1,807 (23.12%) 10,395 ( 4.97%)     3 ( 0.12%)   0           ./elf/./elf/do-rel.h:_dl_relocate_object
 78,187 ( 3.27%)  89 ( 3.91%)  74 ( 3.41%)  19,259 ( 3.34%)   273 ( 1.95%)   136 ( 1.74%)      0              0            0           ./string/../sysdeps/x86_64/strcmp.S:strcmp
 37,135 ( 1.55%)   5 ( 0.22%)   5 ( 0.23%)   6,725 ( 1.16%)    74 ( 0.53%)    74 ( 0.95%)      6 ( 0.00%)     1 ( 0.04%)   1 ( 0.06%)  ./elf/./elf/dl-tunables.c:__GI___tunables_init
 20,049 ( 0.84%)   0            0                0              0              0           4,462 ( 2.13%)     0            0           ./elf/../sysdeps/generic/dl-protected.h:do_lookup_x
 12,128 ( 0.51%)   6 ( 0.26%)   6 ( 0.28%)   3,552 ( 0.62%)     1 ( 0.01%)     0             256 ( 0.12%)     0            0           ???:std::locale::_Impl::_M_install_facet(std::locale::id const*, std::locale::facet const*)
 12,092 ( 0.51%)  20 ( 0.88%)  20 ( 0.92%)   4,192 ( 0.73%)    91 ( 0.65%)    84 ( 1.07%)    869 ( 0.42%)    67 ( 2.69%)  65 ( 4.01%)  ./elf/./elf/dl-version.c:_dl_check_map_versions
 11,080 ( 0.46%)   1 ( 0.04%)   1 ( 0.05%)   2,216 ( 0.38%)     0              0               0              0            0           ./elf/../sysdeps/generic/ldsodefs.h:do_lookup_x
 10,281 ( 0.43%)   0            0            3,427 ( 0.59%)     0              0               0              0            0           ./elf/../sysdeps/generic/ldsodefs.h:_dl_relocate_object
 10,240 ( 0.43%)   4 ( 0.18%)   4 ( 0.18%)   3,072 ( 0.53%)     4 ( 0.03%)     0           1,536 ( 0.73%)     0            0           ./wcsmbs/./wcsmbs/btowc.c:btowc
  8,278 ( 0.35%)   7 ( 0.31%)   7 ( 0.32%)   2,992 ( 0.52%)   279 ( 1.99%)    54 ( 0.69%)    795 ( 0.38%)     1 ( 0.04%)   0           ./elf/./elf/dl-runtime.c:_dl_fixup
  4,827 ( 0.20%)   1 ( 0.04%)   1 ( 0.05%)     930 ( 0.16%)     1 ( 0.01%)     1 ( 0.01%)      0              0            0           ./elf/./elf/dl-tunables.h:__GI___tunables_init
  4,487 ( 0.19%) 298 (13.09%) 271 (12.51%)   2,005 ( 0.35%)   165 ( 1.18%)    10 ( 0.13%)    453 ( 0.22%)    21 ( 0.84%)  13 ( 0.80%)  ???:???
  4,174 ( 0.17%)  16 ( 0.70%)  16 ( 0.74%)     331 ( 0.06%)    58 ( 0.41%)     0             143 ( 0.07%)     1 ( 0.04%)   0           ./elf/./elf/dl-reloc.c:_dl_relocate_object
  3,782 ( 0.16%)  41 ( 1.80%)  41 ( 1.89%)     825 ( 0.14%)    54 ( 0.39%)    54 ( 0.69%)    394 ( 0.19%)    22 ( 0.88%)  22 ( 1.36%)  ./elf/./elf/dl-load.c:_dl_map_object_from_fd
  3,720 ( 0.16%)   4 ( 0.18%)   4 ( 0.18%)     546 ( 0.09%)    30 ( 0.21%)    30 ( 0.38%)      0              0            0           ./elf/./elf/dl-cache.c:_dl_cache_libcmp
  3,608 ( 0.15%)   4 ( 0.18%)   4 ( 0.18%)   4,224 ( 0.73%)     1 ( 0.01%)     0           4,400 ( 2.10%)    11 ( 0.44%)   4 ( 0.25%)  ./elf/../sysdeps/x86_64/dl-trampoline.h:_dl_runtime_resolve_xsave
  3,456 ( 0.14%)   3 ( 0.13%)   3 ( 0.14%)     896 ( 0.16%)     0              0             512 ( 0.24%)     0            0           ./wcsmbs/./wcsmbs/wctob.c:wctob
  3,424 ( 0.14%)   0            0            1,284 ( 0.22%)     0              0           1,284 ( 0.61%)    12 ( 0.48%)  12 ( 0.74%)  /home/neg/Documents/dev/ed_ufmg/TP01/src/utils.cpp:evaluateExpression(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int*)::Element::Element()
  3,269 ( 0.14%)  10 ( 0.44%)  10 ( 0.46%)     499 ( 0.09%)     8 ( 0.06%)     8 ( 0.10%)     78 ( 0.04%)     0            0           ./elf/../sysdeps/x86/dl-cacheinfo.h:intel_check_word.constprop.0
  2,848 ( 0.12%)   2 ( 0.09%)   2 ( 0.09%)     761 ( 0.13%)     0              0             443 ( 0.21%)     1 ( 0.04%)   1 ( 0.06%)  ./elf/./elf/dl-misc.c:_dl_name_match_p
  2,733 ( 0.11%)   4 ( 0.18%)   4 ( 0.18%)       5 ( 0.00%)     0              0             810 ( 0.39%)    20 ( 0.80%)  20 ( 1.23%)  ???:std::ctype<wchar_t>::_M_initialize_ctype()
  2,544 ( 0.11%)   3 ( 0.13%)   3 ( 0.14%)      40 ( 0.01%)     0              0             440 ( 0.21%)     0            0           /home/neg/Documents/dev/ed_ufmg/TP01/include/stack.h:Stack<evaluateExpression(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> >, int*)::Element>::Stack(unsigned long)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/neg/Documents/dev/ed_ufmg/TP01/include/stack.h
--------------------------------------------------------------------------------
Ir             I1mr       ILmr       Dr           D1mr       DLmr       Dw           D1mw       DLmw       

-- line 17 ----------------------------------------
    .          .          .            .          .          .            .          .          .           
    .          .          .            .          .          .            .          .          .           public:
    .          .          .            .          .          .            .          .          .           
    .          .          .            .          .          .            .          .          .               /**
    .          .          .            .          .          .            .          .          .                * @brief Constroi um novo objeto Stack
    .          .          .            .          .          .            .          .          .                * 
    .          .          .            .          .          .            .          .          .                * @param max_size Tamanho máximo da pilha
    .          .          .            .          .          .            .          .          .                */
   73 ( 0.00%) 3 ( 0.13%) 3 ( 0.14%)  18 ( 0.00%) 0          0           42 ( 0.02%) 0          0               Stack(size_t max_size) : max_size(max_size), top_index(0) {
2,481 ( 0.10%) 3 ( 0.13%) 3 ( 0.14%)  12 ( 0.00%) 0          0          412 ( 0.20%) 0          0                   elements = new T[max_size];
   34 ( 0.00%) 0          0           24 ( 0.00%) 0          0            0          0          0               }
    .          .          .            .          .          .            .          .          .           
    .          .          .            .          .          .            .          .          .               /**
    .          .          .            .          .          .            .          .          .                * @brief Destrói o objeto Stack
    .          .          .            .          .          .            .          .          .                * 
    .          .          .            .          .          .            .          .          .                */
   25 ( 0.00%) 0          0            0          0          0           12 ( 0.01%) 0          0               ~Stack() {
   48 ( 0.00%) 0          0           24 ( 0.00%) 0          0            6 ( 0.00%) 0          0                   delete[] elements;
   18 ( 0.00%) 0          0           12 ( 0.00%) 0          0            0          0          0               }
    .          .          .            .          .          .            .          .          .           
    .          .          .            .          .          .            .          .          .               /**
    .          .          .            .          .          .            .          .          .                * @brief Insere um elemento no topo da pilha
    .          .          .            .          .          .            .          .          .                * @throw std::overflow_error Se a pilha estiver cheia
    .          .          .            .          .          .            .          .          .                * @param value Valor a ser inserido
    .          .          .            .          .          .            .          .          .                */
  290 ( 0.01%) 3 ( 0.13%) 3 ( 0.14%)   0          0          0          205 ( 0.10%) 0          0               void push(const T& value) {
  246 ( 0.01%) 0          0          164 ( 0.03%) 0          0            0          0          0                   if (top_index < max_size) {
  489 ( 0.02%) 3 ( 0.13%) 3 ( 0.14%) 287 ( 0.05%) 0          0           82 ( 0.04%) 1 ( 0.04%) 1 ( 0.06%)              elements[top_index++] = value;
   41 ( 0.00%) 0          0            0          0          0            0          0          0                       return ;
    .          .          .            .          .          .            .          .          .                   }
    .          .          .            .          .          .            .          .          .                   // Stack overflow
    .          .          .            .          .          .            .          .          .                   throw std::overflow_error("Stack is full");
  205 ( 0.01%) 3 ( 0.13%) 3 ( 0.14%) 164 ( 0.03%) 0          0            0          0          0               }
    .          .          .            .          .          .            .          .          .           
    .          .          .            .          .          .            .          .          .               /**
    .          .          .            .          .          .            .          .          .                * @brief Remove o elemento do topo da pilha
    .          .          .            .          .          .            .          .          .                * @throw std::underflow_error Se a pilha estiver vazia
    .          .          .            .          .          .            .          .          .                */
  249 ( 0.01%) 2 ( 0.09%) 2 ( 0.09%)   0          0          0          164 ( 0.08%) 0          0               void pop() {
  164 ( 0.01%) 0          0           82 ( 0.01%) 0          0            0          0          0                   if (top_index > 0) {
  205 ( 0.01%) 0          0          123 ( 0.02%) 0          0           41 ( 0.02%) 0          0                       --top_index;
   41 ( 0.00%) 0          0            0          0          0            0          0          0                       return;
    .          .          .            .          .          .            .          .          .                   }
    .          .          .            .          .          .            .          .          .                   // Stack underflow
    .          .          .            .          .          .            .          .          .                   throw std::underflow_error("Stack is empty");
  205 ( 0.01%) 3 ( 0.13%) 3 ( 0.14%) 164 ( 0.03%) 0          0            0          0          0               }
    .          .          .            .          .          .            .          .          .           
    .          .          .            .          .          .            .          .          .               /**
    .          .          .            .          .          .            .          .          .                * @brief Retorna o elemento do topo da pilha
    .          .          .            .          .          .            .          .          .                * @throw std::underflow_error Se a pilha estiver vazia
    .          .          .            .          .          .            .          .          .                * @return T Elemento do topo da pilha
    .          .          .            .          .          .            .          .          .                */
  263 ( 0.01%) 1 ( 0.04%) 1 ( 0.05%)   0          0          0          172 ( 0.08%) 0          0               T top() const {
  172 ( 0.01%) 1 ( 0.04%) 1 ( 0.05%)  86 ( 0.01%) 0          0            0          0          0                   if (top_index > 0) {
  382 ( 0.02%) 2 ( 0.09%) 2 ( 0.09%) 215 ( 0.04%) 0          0            0          0          0                       return elements[top_index - 1];
    .          .          .            .          .          .            .          .          .                   }
    .          .          .            .          .          .            .          .          .                   throw std::underflow_error("Stack is empty"); // Stack is empty
  215 ( 0.01%) 4 ( 0.18%) 4 ( 0.18%) 172 ( 0.03%) 0          0            0          0          0               }
    .          .          .            .          .          .            .          .          .           
    .          .          .            .          .          .            .          .          .               /**
    .          .          .            .          .          .            .          .          .                * @brief Verifica se a pilha está vazia
    .          .          .            .          .          .            .          .          .                * 
    .          .          .            .          .          .            .          .          .                * @return true Se a pilha estiver vazia
    .          .          .            .          .          .            .          .          .                * @return false Se a pilha não estiver vazia
    .          .          .            .          .          .            .          .          .                */
   61 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)   0          0          0           36 ( 0.02%) 0          0               bool isEmpty() const {
   72 ( 0.00%) 0          0           36 ( 0.01%) 0          0            0          0          0                   return top_index == 0;
   36 ( 0.00%) 0          0           36 ( 0.01%) 0          0            0          0          0               }
    .          .          .            .          .          .            .          .          .           
    .          .          .            .          .          .            .          .          .               /**
    .          .          .            .          .          .            .          .          .                * @brief Retorna o tamanho da pilha
    .          .          .            .          .          .            .          .          .                * 
    .          .          .            .          .          .            .          .          .                * @return size_t Tamanho da pilha
    .          .          .            .          .          .            .          .          .                */
    .          .          .            .          .          .            .          .          .               size_t size() const {
    .          .          .            .          .          .            .          .          .                   return top_index;
-- line 92 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/neg/Documents/dev/ed_ufmg/TP01/src/utils.cpp
--------------------------------------------------------------------------------
Ir             I1mr       ILmr       Dr             D1mr       DLmr       Dw             D1mw        DLmw        

-- line 5 ----------------------------------------
    .          .          .              .          .          .              .           .           .           #include <cstring>
    .          .          .              .          .          .              .           .           .           #include <string>
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .           #include <cassert>
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .           const int MAX_SIZE_QUANTIFIERS = 10;
    .          .          .              .          .          .              .           .           .           const size_t MAX_SIZE_STACK  = 100;
    .          .          .              .          .          .              .           .           .           
   20 ( 0.00%) 1 ( 0.04%) 0              0          0          0              8 ( 0.00%)  0           0           int getPrecedence(char op) {
   30 ( 0.00%) 0          0              4 ( 0.00%) 0          0              0           0           0               switch (op) {
    .          .          .              .          .          .              .           .           .                   case '|':
    2 ( 0.00%) 0          0              0          0          0              0           0           0                       return 1;
    .          .          .              .          .          .              .           .           .                   case '&':
    6 ( 0.00%) 0          0              0          0          0              0           0           0                       return 2;
    .          .          .              .          .          .              .           .           .                   case '~':
    .          .          .              .          .          .              .           .           .                       return 3;
    .          .          .              .          .          .              .           .           .                   default:
    .          .          .              .          .          .              .           .           .                       return 0;
    .          .          .              .          .          .              .           .           .               }
    8 ( 0.00%) 0          0              8 ( 0.00%) 0          0              0           0           0           }
    .          .          .              .          .          .              .           .           .           
   10 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     1 ( 0.00%) 0          0              5 ( 0.00%)  0           0           std::string infixToPostfix(const char* infix) {
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .               // Pilha para armazenar os operadores e parenteses
    4 ( 0.00%) 0          0              0          0          0              1 ( 0.00%)  0           0               Stack<char> stack = Stack<char>(MAX_SIZE_STACK);
    .          .          .              .          .          .              .           .           .           
    3 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%)  0           0               std::string postfix;
    .          .          .              .          .          .              .           .           .               
    .          .          .              .          .          .              .           .           .               // Percorrendo a expressão infixa
  113 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)    55 ( 0.01%) 0          0              1 ( 0.00%)  0           0               for (int cont = 0; infix[cont] != '\0'; cont++) {
   97 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    39 ( 0.01%) 0          0              0           0           0                   if (infix[cont] == ' ') continue; 
    .          .          .              .          .          .              .           .           .                   
   42 ( 0.00%) 0          0             21 ( 0.00%) 0          0              7 ( 0.00%)  0           0                   char c = infix[cont];
    .          .          .              .          .          .              .           .           .           
   51 ( 0.00%) 0          0             17 ( 0.00%) 0          0              0           0           0                   if(c == '|' || c == '&' || c == '~'){
    .          .          .              .          .          .              .           .           .                       // Se for um operador, verifica se eh necessario resgatar valores da pilha
   53 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     2 ( 0.00%) 0          0              9 ( 0.00%)  0           0                       while (!stack.isEmpty() && getPrecedence(c) < getPrecedence(stack.top())) {
    .          .          .              .          .          .              .           .           .                           postfix += stack.top();
    .          .          .              .          .          .              .           .           .                           stack.pop();
    .          .          .              .          .          .              .           .           .                       }
    .          .          .              .          .          .              .           .           .           
   18 ( 0.00%) 0          0              0          0          0              3 ( 0.00%)  0           0                       stack.push(c);
    .          .          .              .          .          .              .           .           .                   }
   12 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     4 ( 0.00%) 0          0              0           0           0                   else if(c == '('){
    .          .          .              .          .          .              .           .           .                       stack.push(c);
    .          .          .              .          .          .              .           .           .                   }
   12 ( 0.00%) 0          0              4 ( 0.00%) 0          0              0           0           0                   else if(c == ')'){
    .          .          .              .          .          .              .           .           .                       // Resgata a expressão entre parenteses
    .          .          .              .          .          .              .           .           .                       while (stack.top() != '(') {
    .          .          .              .          .          .              .           .           .                           postfix += stack.top();
    .          .          .              .          .          .              .           .           .                           stack.pop();
    .          .          .              .          .          .              .           .           .                       }
    .          .          .              .          .          .              .           .           .                       if (stack.top() == '(') stack.pop();
    .          .          .              .          .          .              .           .           .                   }
    .          .          .              .          .          .              .           .           .                   else{
    .          .          .              .          .          .              .           .           .                       // Se for uma variavel, ja a adiciona na pilha
   28 ( 0.00%) 0          0              8 ( 0.00%) 0          0              4 ( 0.00%)  0           0                       postfix += c;
    .          .          .              .          .          .              .           .           .                   }
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .               }
    .          .          .              .          .          .              .           .           .               
    .          .          .              .          .          .              .           .           .               // Resgata o restante dos operadores
   25 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0              4 ( 0.00%)  0           0               while (!stack.isEmpty()) {
   24 ( 0.00%) 0          0              3 ( 0.00%) 0          0              6 ( 0.00%)  0           0                   postfix += stack.top();
    9 ( 0.00%) 0          0              0          0          0              3 ( 0.00%)  0           0                   stack.pop();
    .          .          .              .          .          .              .           .           .               }
    .          .          .              .          .          .              .           .           .               
    2 ( 0.00%) 0          0              0          0          0              0           0           0               return postfix;
   10 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     6 ( 0.00%) 0          0              1 ( 0.00%)  0           0           }
    .          .          .              .          .          .              .           .           .           
   40 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     4 ( 0.00%) 0          0             20 ( 0.01%)  0           0           bool evaluateExpression(std::string exp, int arr[100]){
    4 ( 0.00%) 0          0              0          0          0              4 ( 0.00%)  0           0               size_t i = 0;
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .               // Struct para armazenar os dados de cada elemento da pilha
    .          .          .              .          .          .              .           .           .               struct Element{
    .          .          .              .          .          .              .           .           .                   bool isresolved = false;
    .          .          .              .          .          .              .           .           .                   int el;
  420 ( 0.02%) 0          0            168 ( 0.03%) 0          0            168 ( 0.08%)  0           0                   Element(bool val, int el): isresolved(val), el(el){}
3,424 ( 0.14%) 0          0          1,284 ( 0.22%) 0          0          1,284 ( 0.61%) 12 ( 0.48%) 12 ( 0.74%)          Element(){}
    .          .          .              .          .          .              .           .           .               };
    .          .          .              .          .          .              .           .           .           
   16 ( 0.00%) 0          0              0          0          0              4 ( 0.00%)  0           0               Stack<Element> stack(MAX_SIZE_STACK);
  228 ( 0.01%) 1 ( 0.04%) 1 ( 0.05%)    64 ( 0.01%) 0          0             32 ( 0.02%)  0           0               while(i < exp.size()){
   84 ( 0.00%) 0          0              0          0          0             28 ( 0.01%)  0           0                   Element aux;
    .          .          .              .          .          .              .           .           .           
  280 ( 0.01%) 1 ( 0.04%) 1 ( 0.05%)    84 ( 0.01%) 0          0             28 ( 0.01%)  0           0                   if(exp[i] == '~'){ // Resolve o topo da pilha -> Inverte ele
    .          .          .              .          .          .              .           .           .                       aux = stack.top(); 
    .          .          .              .          .          .              .           .           .                       int val = (aux.isresolved ? aux.el : arr[aux.el]); 
    .          .          .              .          .          .              .           .           .                       stack.pop();
    .          .          .              .          .          .              .           .           .                       stack.push(Element{true, !val});
    .          .          .              .          .          .              .           .           .                   }
  512 ( 0.02%) 2 ( 0.09%) 2 ( 0.09%)   156 ( 0.03%) 0          0             52 ( 0.02%)  0           0                   else if(exp[i] == '|' || exp[i] == '&'){ // Resolve os dois nós do top da pilha -> empilha o resultado 
    .          .          .              .          .          .              .           .           .           
   48 ( 0.00%) 0          0              0          0          0             24 ( 0.01%)  0           0                       aux = stack.top();
   88 ( 0.00%) 0          0             32 ( 0.01%) 0          0             12 ( 0.01%)  0           0                       int val1 = (aux.isresolved ? aux.el : arr[aux.el]); 
   36 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0             12 ( 0.01%)  0           0                       stack.pop();
    .          .          .              .          .          .              .           .           .           
   48 ( 0.00%) 0          0              0          0          0             24 ( 0.01%)  0           0                       aux = stack.top();
  120 ( 0.01%) 0          0             48 ( 0.01%) 0          0             12 ( 0.01%)  0           0                       int val2 = (aux.isresolved ? aux.el : arr[aux.el]); 
   36 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0             12 ( 0.01%)  0           0                       stack.pop();
    .          .          .              .          .          .              .           .           .                       
  179 ( 0.01%) 1 ( 0.04%) 1 ( 0.05%)    54 ( 0.01%) 0          0             24 ( 0.01%)  0           0                       int res = (exp[i] == '|'? (val1 || val2): (val1 && val2));
    .          .          .              .          .          .              .           .           .           
  132 ( 0.01%) 0          0             12 ( 0.00%) 0          0             24 ( 0.01%)  0           0                       stack.push(Element{true, res});
    .          .          .              .          .          .              .           .           .                   }
    .          .          .              .          .          .              .           .           .                   else {
  272 ( 0.01%) 1 ( 0.04%) 1 ( 0.05%)    48 ( 0.01%) 0          0             48 ( 0.02%)  0           0                       stack.push(Element{false, exp[i] - '0'});
    .          .          .              .          .          .              .           .           .                   }
   28 ( 0.00%) 0          0             28 ( 0.00%) 0          0              0           0           0                   i++;
    .          .          .              .          .          .              .           .           .               }
   16 ( 0.00%) 0          0              0          0          0              8 ( 0.00%)  0           0               Element aux = stack.top(); 
   12 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0              4 ( 0.00%)  0           0               stack.pop();
   32 ( 0.00%) 0          0              8 ( 0.00%) 0          0              0           0           0               return (aux.isresolved?aux.el:arr[aux.el]);
   36 ( 0.00%) 0          0             20 ( 0.00%) 0          0              4 ( 0.00%)  0           0           }
    .          .          .              .          .          .              .           .           .           
   40 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     4 ( 0.00%) 0          0             20 ( 0.01%)  0           0           bool evaluateExpression(std::string exp, std::string vals){
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .               // Transformar a string de valores em um array de inteiros
    .          .          .              .          .          .              .           .           .               int arr[100];
  324 ( 0.01%) 2 ( 0.09%) 2 ( 0.09%)   120 ( 0.02%) 0          0             56 ( 0.03%)  0           0               for(size_t i = 0; i < vals.size(); i++) arr[i] = vals[i] - '0';
   64 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     4 ( 0.00%) 0          0             12 ( 0.01%)  0           0               return evaluateExpression(exp, arr);
   24 ( 0.00%) 0          0             20 ( 0.00%) 0          0              0           0           0           }
    .          .          .              .          .          .              .           .           .           
   12 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     1 ( 0.00%) 0          0              7 ( 0.00%)  0           0           std::string sat_tree(std::string postfix_exp, std::string vals){
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .               // Lista dos indices dos quantificadores
    .          .          .              .          .          .              .           .           .               int idx_quantifier[MAX_SIZE_QUANTIFIERS]; 
    5 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0              1 ( 0.00%)  0           0               memset(idx_quantifier, -1, sizeof(idx_quantifier)); // -1 significa que não há mais quantificadores
    .          .          .              .          .          .              .           .           .               
    1 ( 0.00%) 0          0              0          0          0              1 ( 0.00%)  0           0               int qtd_quantifier = 0; 
   41 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    14 ( 0.00%) 0          0              6 ( 0.00%)  0           0               for(size_t idx = 0; idx < vals.size(); idx++) 
   62 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    18 ( 0.00%) 0          0              6 ( 0.00%)  0           0                   if(vals[idx] == 'e' || vals[idx] == 'a') 
   14 ( 0.00%) 0          0              4 ( 0.00%) 0          0              4 ( 0.00%)  0           0                       idx_quantifier[qtd_quantifier ++] = idx; 
    .          .          .              .          .          .              .           .           .               
    .          .          .              .          .          .              .           .           .               // Tipos para verficarmos qual operação deve ser feita após obter os valores dos nós filhos
    .          .          .              .          .          .              .           .           .               enum types {    
    .          .          .              .          .          .              .           .           .                   AND, OR, NONE
    .          .          .              .          .          .              .           .           .               };
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .               // Struct para armazenar os dados de cada nó
  381 ( 0.02%) 1 ( 0.04%) 1 ( 0.05%)   149 ( 0.03%) 0          0            101 ( 0.05%)  1 ( 0.04%)  1 ( 0.06%)      struct Element{
    .          .          .              .          .          .              .           .           .                   int idx; // indice do quantificador, entre os demais quantificadores (ex: 0 -> primeiro quantificador)
    .          .          .              .          .          .              .           .           .                   enum types type;
    .          .          .              .          .          .              .           .           .                   std::string data;
    .          .          .              .          .          .              .           .           .                   bool res;
  112 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    28 ( 0.00%) 0          0             56 ( 0.03%)  0           0                   Element(std::string data, int idx): idx(idx), res(false){
   42 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    14 ( 0.00%) 0          0              7 ( 0.00%)  0           0                       this->data = data;
   28 ( 0.00%) 0          0             21 ( 0.00%) 0          0              0           0           0                   }
    .          .          .              .          .          .              .           .           .               };
    .          .          .              .          .          .              .           .           .           
   25 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     2 ( 0.00%) 0          0              7 ( 0.00%)  0           0               TreeNode<Element> *root = new TreeNode<Element>(Element{vals, qtd_quantifier});
    2 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%)  0           0               TreeNode<Element> *cur = root;
    .          .          .              .          .          .              .           .           .           
    4 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0              1 ( 0.00%)  0           0               Stack<TreeNode<Element>*> stack(MAX_SIZE_STACK);
    .          .          .              .          .          .              .           .           .           
    5 ( 0.00%) 0          0              0          0          0              1 ( 0.00%)  0           0               stack.push(root);
   67 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0             11 ( 0.01%)  0           0               while(!stack.isEmpty()){
   70 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0             30 ( 0.01%)  0           0                   cur = stack.top(); stack.pop();
   40 ( 0.00%) 0          0             20 ( 0.00%) 0          0             10 ( 0.00%)  0           0                   int i = cur->value.idx - 1; // Indice de controle sobre a posicao dos quantificadores
    .          .          .              .          .          .              .           .           .                   
    .          .          .              .          .          .              .           .           .                   // Se o nó atual é uma folha, podemos resolvê-lo 
   20 ( 0.00%) 0          0             10 ( 0.00%) 0          0              0           0           0                   if(i == -1){ // || idx_quantifier[i] == -1
   96 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    12 ( 0.00%) 0          0             24 ( 0.01%)  0           0                       cur->value.res = evaluateExpression(postfix_exp, cur->value.data);
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .                       // LOG
    .          .          .              .          .          .              .           .           .                       // std::cout << "FOLHA " << cur->value.data << ", RES: " << cur->value.res << "\n";
    4 ( 0.00%) 0          0              0          0          0              0           0           0                       continue;
    .          .          .              .          .          .              .           .           .                   }
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .                   // Caso não seja uma folha, e já possua filhos resolvidos, podemos resolver o nó atual
   36 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    18 ( 0.00%) 0          0              0           0           0                   if(cur->left != nullptr && cur->right != nullptr){ // Talvez ocorra algum erro aqui !!!
    .          .          .              .          .          .              .           .           .                       
    .          .          .              .          .          .              .           .           .                       // LOG
    .          .          .              .          .          .              .           .           .                       // std::cout << "NO INTERNO " << (cur->value.type == AND?"AND ":"OR ") << cur->value.data << "\n";
    .          .          .              .          .          .              .           .           .           
   24 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    18 ( 0.00%) 0          0              6 ( 0.00%)  0           0                       bool left = cur->left->value.res, right = cur->right->value.res;
   32 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    13 ( 0.00%) 0          0              3 ( 0.00%)  0           0                       cur->value.res = (cur->value.type == AND ? (left && right) : (left || right));
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .                       // Compondo a string de satisfatibilidade
   10 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     5 ( 0.00%) 0          0              0           0           0                       if(left && right) { // Tanto faz o valor da variavel
   28 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     8 ( 0.00%) 0          0              4 ( 0.00%)  0           0                           std::string val_left = cur->left->value.data, val_right = cur->right->value.data; 
    .          .          .              .          .          .              .           .           .           
   12 ( 0.00%) 0          0              2 ( 0.00%) 0          0              2 ( 0.00%)  0           0                           cur->value.data = val_left;
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .                           // Faz a verificação até o quantificador anterior
   42 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)    24 ( 0.00%) 0          0              2 ( 0.00%)  0           0                           for(int i = 0; i < cur->value.idx && idx_quantifier[i] != -1; i++){
   12 ( 0.00%) 0          0              6 ( 0.00%) 0          0              3 ( 0.00%)  0           0                               int idx = idx_quantifier[i];
   54 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    12 ( 0.00%) 0          0              6 ( 0.00%)  0           0                               if(val_left[idx] != val_right[idx]){
    .          .          .              .          .          .              .           .           .                                   // *** 1 *** , *** a *** -> *** 1 ***
    .          .          .              .          .          .              .           .           .                                   // *** 0 *** , *** a *** -> *** 0 ***
    .          .          .              .          .          .              .           .           .                                   // *** 1 *** , *** 0 *** -> *** a ***
    .          .          .              .          .          .              .           .           .                                   // *** 0 *** , *** 1 *** -> *** a ***
    .          .          .              .          .          .              .           .           .           
   72 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    18 ( 0.00%) 0          0             12 ( 0.01%)  0           0                                   cur->value.data[idx] = (val_left[idx] == 'a'? val_right[idx]: val_left[idx]);
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .                               }
    .          .          .              .          .          .              .           .           .                           }
    .          .          .              .          .          .              .           .           .                           
   24 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)    10 ( 0.00%) 0          0              4 ( 0.00%)  0           0                           cur->value.data[idx_quantifier[cur->left->value.idx]] = 'a';
   14 ( 0.00%) 0          0              0          0          0              4 ( 0.00%)  0           0                       }
    2 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     1 ( 0.00%) 0          0              0           0           0                       else if (left){ // left é o nó que possui o valor falso
    .          .          .              .          .          .              .           .           .                           cur->value.data = cur->left->value.data;
    .          .          .              .          .          .              .           .           .                           cur->value.data[idx_quantifier[cur->left->value.idx]] = '0';
    2 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     1 ( 0.00%) 0          0              0           0           0                       }else if(right){ // right é o nó que possui o valor verdadeiro
    8 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     3 ( 0.00%) 0          0              1 ( 0.00%)  0           0                           cur->value.data = cur->right->value.data;
   12 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     5 ( 0.00%) 0          0              2 ( 0.00%)  0           0                           cur->value.data[idx_quantifier[cur->right->value.idx]] = '1';
    .          .          .              .          .          .              .           .           .                       }
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .                       // Deletando os filhos 
   54 ( 0.00%) 0          0             12 ( 0.00%) 0          0             12 ( 0.01%)  0           0                       delete cur->left; delete cur->right;
   12 ( 0.00%) 0          0              6 ( 0.00%) 0          0              6 ( 0.00%)  0           0                       cur->left = nullptr; cur->right = nullptr;
    3 ( 0.00%) 0          0              0          0          0              0           0           0                       continue;
    .          .          .              .          .          .              .           .           .                   }
    .          .          .              .          .          .              .           .           .           
    .          .          .              .          .          .              .           .           .                   // Caso não seja uma folha, e não possua filhos resolvidos, devemos criar os filhos
    .          .          .              .          .          .              .           .           .           
   30 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)    12 ( 0.00%) 0          0              6 ( 0.00%)  0           0                   char val = vals[idx_quantifier[i]]; 
   15 ( 0.00%) 0          0              6 ( 0.00%) 0          0              3 ( 0.00%)  0           0                   cur->value.type = (val == 'a' ? AND : OR); // Tipo de operação que deverá ser realizada após obter os valores dos filhos
    .          .          .              .          .          .              .           .           .           
   45 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     9 ( 0.00%) 0          0              9 ( 0.00%)  0           0                   std::string copy = cur->value.data; copy[idx_quantifier[i]] = '0';
   75 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     3 ( 0.00%) 0          0             21 ( 0.01%)  0           0                   TreeNode<Element> *left_node = new TreeNode<Element>(Element{copy, i}); 
    .          .          .              .          .          .              .           .           .                   
   27 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     6 ( 0.00%) 0          0              6 ( 0.00%)  0           0                   copy[idx_quantifier[i]] = '1';
   75 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     3 ( 0.00%) 0          0             21 ( 0.01%)  0           0                   TreeNode<Element> *right_node = new TreeNode<Element>(Element{copy, i});
    .          .          .              .          .          .              .           .           .                   
   15 ( 0.00%) 0          0              6 ( 0.00%) 0          0              3 ( 0.00%)  0           0                   BinaryTree<Element>::insertLeft(cur, left_node);
   15 ( 0.00%) 0          0              6 ( 0.00%) 0          0              3 ( 0.00%)  0           0                   BinaryTree<Element>::insertRight(cur, right_node);
    .          .          .              .          .          .              .           .           .           
   45 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     0          0          0              9 ( 0.00%)  0           0                   stack.push(cur); stack.push(right_node); stack.push(left_node); // Empilhando os nós
    9 ( 0.00%) 0          0              0          0          0              3 ( 0.00%)  0           0               }
    .          .          .              .          .          .              .           .           .               
    .          .          .              .          .          .              .           .           .               // std::cout << "ROOT: " << (root->value.type == AND ? "AND": root->value.type == OR? "OR": "NONE") << " " << root->value.res << "\n";
    6 ( 0.00%) 0          0              1 ( 0.00%) 0          0              1 ( 0.00%)  0           0               Element aux = cur->value;
    8 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)     1 ( 0.00%) 0          0              2 ( 0.00%)  0           0               delete cur;
    4 ( 0.00%) 0          0              1 ( 0.00%) 0          0              0           0           0               if(!(aux.res)) return "";
    6 ( 0.00%) 2 ( 0.09%) 2 ( 0.09%)     1 ( 0.00%) 0          0              1 ( 0.00%)  0           0               return aux.data;
   36 ( 0.00%) 3 ( 0.13%) 3 ( 0.14%)    13 ( 0.00%) 1 ( 0.01%) 0              7 ( 0.00%)  0           0           }

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../sysdeps/generic/dl-protected.h
  ./elf/../sysdeps/generic/ldsodefs.h
  ./elf/../sysdeps/x86/dl-cacheinfo.h
  ./elf/../sysdeps/x86_64/dl-machine.h
  ./elf/../sysdeps/x86_64/dl-trampoline.h
  ./elf/./elf/dl-cache.c
  ./elf/./elf/dl-load.c
  ./elf/./elf/dl-lookup.c
  ./elf/./elf/dl-misc.c
  ./elf/./elf/dl-reloc.c
  ./elf/./elf/dl-runtime.c
  ./elf/./elf/dl-tunables.c
  ./elf/./elf/dl-tunables.h
  ./elf/./elf/dl-version.c
  ./elf/./elf/do-rel.h
  ./string/../sysdeps/x86_64/strcmp.S
  ./wcsmbs/./wcsmbs/btowc.c
  ./wcsmbs/./wcsmbs/wctob.c

--------------------------------------------------------------------------------
Ir              I1mr         ILmr        Dr             D1mr       DLmr       Dw             D1mw        DLmw        
--------------------------------------------------------------------------------
15,032 ( 0.63%) 100 ( 4.39%) 99 ( 4.57%) 4,474 ( 0.77%) 1 ( 0.01%) 0          3,577 ( 1.71%) 14 ( 0.56%) 14 ( 0.86%)  events annotated

